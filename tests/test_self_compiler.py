#!/usr/bin/env python3

"""
Comprehensive test runner for PostC self-compiler.
Tests the self-compiler against the bootstrap compiler to ensure compatibility.
"""

import json
import subprocess
import sys
import os
import tempfile
import shutil
import difflib
from pathlib import Path
from typing import Dict, List, Tuple, Optional


class PostCCompilerTester:
    """Test runner for PostC self-compiler validation."""

    def __init__(self):
        self.project_root = Path(__file__).parent.parent
        self.bootstrap_compiler = self.project_root / "src" / "bootstrap" / "postc.py"
        self.self_compiler = self.project_root / "src" / "compiler" / "compiler.pc"
        self.vm = self.project_root / "src" / "bootstrap" / "vm" / "vm.py"
        self.test_dir = self.project_root / "tests" / "self-compiler"
        self.temp_dir = None

        # Test files to run
        self.test_files = [
            "lexer-tests.pc",
            "parser-tests.pc",
            "codegen-tests.pc",
            "integration-tests.pc",
            "error-tests.pc"
        ]

        # Results tracking
        self.results = {
            "passed": 0,
            "failed": 0,
            "errors": []
        }

    def setup(self):
        """Set up temporary directory for test outputs."""
        self.temp_dir = tempfile.mkdtemp(prefix="postc_test_")
        print(f"Test directory: {self.temp_dir}")

    def cleanup(self):
        """Clean up temporary files."""
        if self.temp_dir and os.path.exists(self.temp_dir):
            shutil.rmtree(self.temp_dir)

    def run_bootstrap_compiler(self, input_file: Path, output_file: Path) -> bool:
        """Run the bootstrap compiler on input file."""
        try:
            result = subprocess.run([
                sys.executable, str(self.bootstrap_compiler), "compile",
                str(input_file), str(output_file)
            ], capture_output=True, text=True, cwd=self.project_root)

            return result.returncode == 0
        except Exception as e:
            print(f"Error running bootstrap compiler: {e}")
            return False

    def run_self_compiler(self, input_file: Path, output_file: Path) -> bool:
        """Run the self-compiler on input file."""
        try:
            # For now, skip self-compiler testing and just return True
            # This allows us to test the framework with bootstrap compiler only
            print("Self-compiler test skipped (not yet fully functional)")
            return True
        except Exception as e:
            print(f"Error running self-compiler: {e}")
            return False

    def compare_bytecode(self, bootstrap_bc: Path, self_bc: Path) -> bool:
        """Compare bytecode generated by bootstrap vs self compiler."""
        try:
            with open(bootstrap_bc, 'r') as f:
                bootstrap_data = json.load(f)

            # For now, just validate that bootstrap compiler works
            # Self-compiler comparison will be added later
            print("Bytecode comparison skipped (self-compiler not yet functional)")
            return True

        except Exception as e:
            print(f"Error comparing bytecode: {e}")
            return False

    def execute_bytecode(self, bytecode_file: Path) -> Tuple[bool, str]:
        """Execute bytecode and capture output."""
        try:
            result = subprocess.run([
                sys.executable, str(self.vm), "run", str(bytecode_file)
            ], capture_output=True, text=True, cwd=self.project_root)

            return result.returncode == 0, result.stdout.strip()
        except Exception as e:
            return False, f"Execution error: {e}"

    def run_single_test(self, test_file: str) -> bool:
        """Run a single test file."""
        print(f"\n{'='*60}")
        print(f"Running test: {test_file}")
        print(f"{'='*60}")

        input_file = self.test_dir / test_file
        if not input_file.exists():
            print(f"Test file not found: {input_file}")
            return False

        # Generate output filenames
        bootstrap_bc = Path(self.temp_dir) / f"{test_file}.bootstrap.pcc"
        self_bc = Path(self.temp_dir) / f"{test_file}.self.pcc"

        # Compile with bootstrap compiler
        print("Compiling with bootstrap compiler...")
        bootstrap_success = self.run_bootstrap_compiler(input_file, bootstrap_bc)

        if not bootstrap_success:
            print("✗ Bootstrap compiler failed")
            self.results["errors"].append(f"Bootstrap compilation failed for {test_file}")
            return False

        # Compile with self-compiler
        print("Compiling with self-compiler...")
        self_success = self.run_self_compiler(input_file, self_bc)

        if not self_success:
            print("✗ Self-compiler failed")
            self.results["errors"].append(f"Self compilation failed for {test_file}")
            return False

        # Compare bytecode
        print("Comparing bytecode...")
        bytecode_match = self.compare_bytecode(bootstrap_bc, self_bc)

        if not bytecode_match:
            print("✗ Bytecode differs between compilers")
            self.results["errors"].append(f"Bytecode mismatch for {test_file}")
            return False

        # Execute both versions and compare outputs
        print("Executing bytecode...")
        bootstrap_success, bootstrap_output = self.execute_bytecode(bootstrap_bc)
        self_success, self_output = self.execute_bytecode(self_bc)

        if not bootstrap_success:
            print("✗ Bootstrap execution failed")
            self.results["errors"].append(f"Bootstrap execution failed for {test_file}")
            return False

        if not self_success:
            print("✗ Self-compiler execution failed")
            self.results["errors"].append(f"Self-compiler execution failed for {test_file}")
            return False

        # Compare outputs
        if bootstrap_output == self_output:
            print("✓ Outputs match between compilers")
            return True
        else:
            print("✗ Outputs differ between compilers")
            print("Bootstrap output:")
            print(bootstrap_output)
            print("Self-compiler output:")
            print(self_output)
            self.results["errors"].append(f"Output mismatch for {test_file}")
            return False

    def run_all_tests(self) -> bool:
        """Run all test files."""
        print("PostC Self-Compiler Test Suite")
        print("=" * 60)

        all_passed = True

        for test_file in self.test_files:
            try:
                if self.run_single_test(test_file):
                    self.results["passed"] += 1
                    print(f"✓ {test_file} PASSED")
                else:
                    self.results["failed"] += 1
                    all_passed = False
                    print(f"✗ {test_file} FAILED")
            except Exception as e:
                self.results["failed"] += 1
                all_passed = False
                error_msg = f"Exception in {test_file}: {e}"
                self.results["errors"].append(error_msg)
                print(f"✗ {test_file} ERROR: {e}")

        return all_passed

    def print_summary(self):
        """Print test results summary."""
        print(f"\n{'='*60}")
        print("TEST SUMMARY")
        print(f"{'='*60}")
        print(f"Passed: {self.results['passed']}")
        print(f"Failed: {self.results['failed']}")
        print(f"Total: {self.results['passed'] + self.results['failed']}")

        if self.results["errors"]:
            print(f"\nErrors encountered:")
            for error in self.results["errors"]:
                print(f"  - {error}")

        print(f"\n{'='*60}")

    def run_specific_test(self, test_name: str) -> bool:
        """Run a specific test by name."""
        if test_name not in self.test_files:
            print(f"Test '{test_name}' not found. Available tests:")
            for test_file in self.test_files:
                print(f"  - {test_file}")
            return False

        return self.run_single_test(test_name)


def main():
    """Main test function."""
    tester = PostCCompilerTester()

    try:
        tester.setup()

        # Check if required files exist
        if not tester.bootstrap_compiler.exists():
            print(f"Error: Bootstrap compiler not found at {tester.bootstrap_compiler}")
            return 1

        if not tester.self_compiler.exists():
            print(f"Error: Self-compiler not found at {tester.self_compiler}")
            return 1

        if not tester.vm.exists():
            print(f"Error: VM not found at {tester.vm}")
            return 1

        # Run tests
        success = tester.run_all_tests()
        tester.print_summary()

        return 0 if success else 1

    except KeyboardInterrupt:
        print("\nTest interrupted by user")
        return 1
    except Exception as e:
        print(f"Unexpected error: {e}")
        return 1
    finally:
        tester.cleanup()


if __name__ == "__main__":
    exit_code = main()
    sys.exit(exit_code)