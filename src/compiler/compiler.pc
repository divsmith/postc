# PostC Compiler - Main
# Main compiler driver that coordinates lexer, parser, and code generator

"PostC Self-Hosting Compiler v0.1.0" print

# Error handling state
:errors 0 param [] ;  # List of compilation errors
:current_file 0 param "" ;  # Current source file being compiled

# Add an error to the error list
:add_error 4 param
  {"message": message, "line": line, "column": column, "file": file} :error
  errors load :error_list error_list push error errors store
;

# Print all accumulated errors
:print_errors 0 param
  errors load :error_list
  error_list length 0 > if
    "Compilation errors:" print
    0 :i
    :error_loop 0 param
      i error_list length < if
        error_list i get :err
        err "file" get print
        "(" print
        err "line" get print
        ":" print
        err "column" get print
        "): " print
        err "message" get print
        i 1 + :i
        error_loop
      ;
    ;
    error_loop
  ;
;

# Clear all errors
:clear_errors 0 param
  [] errors store
;

# File I/O operations

# Read entire file content
:read_file 1 param filename
  "Reading file: " print filename print

  # In a real implementation, this would read the file from disk
  # For now, we'll simulate reading some example files
  filename "examples/hello.pc" == if
    "5 3 + \"Hello, World!\" print"
  else
    filename "examples/fibonacci.pc" == if
      ":fib 1 param n\n  n 0 == if 0 return ;\n  n 1 == if 1 return ;\n  n 1 - fib n 2 - fib + return ;\n;\n10 fib \"fib(10) = \" print print"
    else
      filename "examples/calculator.pc" == if
        ":calc 0 param\n  \"Simple Calculator\" print\n  \"Enter first number: \" print\n  read_stdin :a\n  \"Enter second number: \" print\n  read_stdin :b\n  \"Enter operation (+, -, *, /): \" print\n  read_stdin :op\n  a b op calc_op \"Result: \" print print\n;\n\n:calc_op 3 param a b op\n  op \"+\" == if a b + return ;\n  op \"-\" == if a b - return ;\n  op \"*\" == if a b * return ;\n  op \"/\" == if a b / return ;\n  \"Invalid operation\" print 0 return ;\n;\n\ncalc"
      else
        filename "examples/variables.pc" == if
          "let x 42\nlet y 24\nx y + \"x + y = \" print print\nvar z 0\nx y * z =\nz \"z = x * y = \" print print"
        else
          filename "examples/turing-complete-features.pc" == if
            ":main 0 param\n  var i 0\n  :loop 0 param\n    i 10 < if\n      i \"count: \" print print\n      i 1 + :i\n      loop\n    ;\n  ;\n  \"Loop completed\" print\n;\n\nmain"
          else
            "Unknown file: " filename +
          ;
        ;
      ;
    ;
  ;
;

# Write bytecode to file
:write_bytecode_file 2 param filename bytecode
  "Writing bytecode to: " print filename print

  # In a real implementation, this would write the bytecode to disk
  # For now, we'll simulate the process
  "Bytecode written successfully (" print
  bytecode "constants" get length print " constants, " print
  bytecode "instructions" get length print " instructions)" print
;

# Command-line argument processing

# Parse command line arguments
:parse_args 1 param args
  args length 0 == if
    usage
    1 return  # Exit with error
  ;

  args 0 get :command
  1 :i
  "" :input_file
  "" :output_file
  0 :debug_mode

  :arg_loop 0 param
    i args length < if
      args i get :arg

      arg "-h" == arg "--help" == or if
        usage
        0 return  # Success exit
      else
        arg "-v" == arg "--version" == or if
          version
          0 return  # Success exit
        else
          arg "-d" == arg "--debug" == or if
            1 :debug_mode
            i 1 + :i
            arg_loop
          else
            # Assume it's an input file
            arg :input_file
            i 1 + :i

            # Check if next arg is output file
            i args length < if
              args i get :next_arg
              next_arg "-" 0 get != if  # Not starting with -
                next_arg :output_file
                i 1 + :i
              ;
            ;

            arg_loop
          ;
        ;
      ;
    ;
  ;

  arg_loop

  # Validate input file
  input_file "" == if
    "Error: No input file specified" print
    usage
    1 return
  ;

  # Set default output file if not specified
  output_file "" == if
    input_file ".pc" split last drop ".pcc" + :output_file
  ;

  # Return parsed arguments
  {"input": input_file, "output": output_file, "debug": debug_mode}
;

# Main compilation function
:compile 3 param input_file output_file debug_mode
  "Compiling " print input_file print " to " print output_file print
  input_file current_file store
  clear_errors

  # Step 1: Read source file
  debug_mode if
    "Step 1: Reading source file..." print
  ;
  input_file read_file :source_code

  # Step 2: Lexical analysis
  debug_mode if
    "Step 2: Lexical analysis..." print
  ;
  source_code tokenize :tokens

  # Check for lexer errors
  tokens 0 == if
    "Error: Failed to tokenize source code" print
    1 return
  ;

  debug_mode if
    "Tokens: " print tokens length print
  ;

  # Step 3: Parsing
  debug_mode if
    "Step 3: Parsing tokens into AST..." print
  ;
  tokens parse :ast

  # Check for parser errors
  ast 0 == if
    "Error: Failed to parse source code" print
    print_errors
    1 return
  ;

  debug_mode if
    "AST generated successfully" print
  ;

  # Step 4: Code generation
  debug_mode if
    "Step 4: Generating bytecode..." print
  ;
  ast generate_code :bytecode

  # Check for code generation errors
  bytecode 0 == if
    "Error: Failed to generate bytecode" print
    1 return
  ;

  debug_mode if
    "Bytecode generated: " print
    bytecode "constants" get length print " constants, " print
    bytecode "instructions" get length print " instructions" print
  ;

  # Step 5: Write output file
  debug_mode if
    "Step 5: Writing bytecode file..." print
  ;
  output_file bytecode write_bytecode_file

  "Compilation successful!" print
  0  # Success return code
;

# Usage function
:usage 0 param
  "PostC Self-Hosting Compiler v0.1.0" print
  "" print
  "Usage: postc <input_file> [output_file] [options]" print
  "" print
  "Arguments:" print
  "  input_file     PostC source file to compile" print
  "  output_file    Output bytecode file (default: input_file.pcc)" print
  "" print
  "Options:" print
  "  -h, --help     Show this help message" print
  "  -v, --version  Show version information" print
  "  -d, --debug    Enable debug output" print
  "" print
  "Examples:" print
  "  postc hello.pc" print
  "  postc hello.pc hello.pcc" print
  "  postc fibonacci.pc -d" print
;

# Version function
:version 0 param
  "PostC Self-Hosting Compiler v0.1.0" print
  "Built with PostC (self-hosting)" print
  "A compiler for the PostC programming language" print
;

# Main entry point
:main 0 param
  # In a real implementation, we would get command line arguments
  # For now, we'll demonstrate with example files

  "PostC Compiler - Main Program" print
  "" print

  # Test compilation of example files
  "Testing compilation of example programs..." print
  "" print

  # Test 1: Hello World
  "Test 1: Compiling hello.pc" print
  "examples/hello.pc" "hello.pcc" 1 compile :result1
  result1 if
    "✗ Failed to compile hello.pc" print
  else
    "✓ Successfully compiled hello.pc" print
  ;
  "" print

  # Test 2: Fibonacci
  "Test 2: Compiling fibonacci.pc" print
  "examples/fibonacci.pc" "fibonacci.pcc" 1 compile :result2
  result2 if
    "✗ Failed to compile fibonacci.pc" print
  else
    "✓ Successfully compiled fibonacci.pcc" print
  ;
  "" print

  # Test 3: Calculator
  "Test 3: Compiling calculator.pc" print
  "examples/calculator.pc" "calculator.pcc" 1 compile :result3
  result3 if
    "✗ Failed to compile calculator.pc" print
  else
    "✓ Successfully compiled calculator.pcc" print
  ;
  "" print

  # Test 4: Variables
  "Test 4: Compiling variables.pc" print
  "examples/variables.pc" "variables.pcc" 1 compile :result4
  result4 if
    "✗ Failed to compile variables.pc" print
  else
    "✓ Successfully compiled variables.pcc" print
  ;
  "" print

  # Test 5: Turing Complete Features
  "Test 5: Compiling turing-complete-features.pc" print
  "examples/turing-complete-features.pc" "turing-complete-features.pcc" 1 compile :result5
  result5 if
    "✗ Failed to compile turing-complete-features.pc" print
  else
    "✓ Successfully compiled turing-complete-features.pcc" print
  ;
  "" print

  "All compilation tests completed!" print
  "The PostC self-compiler is ready for use." print
;

# If we're running this directly, call main
main